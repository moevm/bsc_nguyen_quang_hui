# Разработка программы создания программных макетов учетных систем

Ключевые слова: генерация программного кода, модель «сущность-связь», программный макет

## Аннотация
В работе исследуется возможность автоматизированного создания учётных систем. С этой целью рассматривается применение существующего программного обеспечения – средства проектирования баз данных, коммерческих конструкторов приложений. Описаны их преимущества и ограничения. Существующие аналоги не позволяют решить задачу в полном объёме. Авторами предложено собственное решение создания системы и структуры данных реляционной СУБД на основании модели «сущность-связь», описанной в формате XML. В работе описана архитектура решения и детали реализации.

На примере простой предметной области продемонстрированы основные шаги процесса создания системы. Для созданной системы измерены характеристики быстродействия в зависимости от наполнения и структуры данных, указаны обнаруженные «узкие места» и возможные причины их возникновения.

## Введение
В настоящее время широкое распространение получили реляционные СУБД (РСУБД) [1]. На них часто основаны учётные системы – приложения, хранящие, обрабатывающие информацию и отвечающие на запросы конечного пользователя относительно этой информации.

Создание учётной системы – трудоемкий процесс, требующий разработки как архитектуры БД, так и интерфейса пользователя; часто – кода клиента и сервера. Многие шаги в процессе разработки повторяются вне зависимости от требований к системе.

Существующие сервисы либо решают только часть проблемы (автоматизированное создание только структуры БД), либо дают комплексное решение, часто в формате Software-As-Service, поставляемое на коммерческой основе и не обладающее достаточной расширяемостью (возможностью выполнения произвольного кода на стороне сервера) [2].

Цель данной работы - разработка программы для автоматизации процесса создания клиент-серверного web-приложения на основе ER-диаграммы предметной области.

Решаемые задачи:
* Определить возможность использования существующих решения для решения поставленной задачи
* Определение метода автоматизированного создания структуры БД по ER-диаграмме
* Реализация автоматизированного создания кода сервера для работы с БД и клиента для работы с сервером. Приложение должно быть расширяемым, т.е. поддерживать подключение сторонних скриптов бизнес-логики

## Сравнение аналогов
### Принцип отбора аналогов
Хотя средств, решающих поставленную задачу в полном объеме не обнаружено, возможно использование существующих программных продуктов для решения части задачи.

Рассмотрены представители следующих классов систем:

* Средства для создания структуры БД по формальным моделям
* Средства для генерации кода
* Конструктов приложений

### Создание структуры БД
Существуют средства для работы с ER-моделями и их конвертации в реляционные модели или DDL (Data Description Language). Примеры – веб-приложения ERDPlus [3] и SQLdbm [4]. 

Принцип их работы основан на алгоритме, описанном в [5]. Идея использования – создание ER-модели и применение полученного кода для создания или обновления структуры базы данных. SqlDBM может сгенерировать ER-модель по DDL (реверс-инжиниринг). 

Другой вариант – MySQL Workbench. В его функциональность, помимо средств администрирования БД (только MySQL), входит создание структуры БД по ER-модели и наоборот. Вместе с возможностью профилирования и отладки SQL-запросов, инструмент может использоваться для макетирования базы данных [6].

Данные средства могут автоматизировать создание структуры БД, но не приложения для конечного пользователя, поэтому их использование в контексте рассматриваемой задачи ограничено.

### Генерация кода
Как и рассмотренные приложения, CASE-средство Visual Paradigm можно использовать для моделирования структуры БД. Отличительная особенность – возможность генерации программного кода для JPA или ORM-фреймворка Hibernate (Java) [7].

Таким образом, макетируется не только база данных, но и элементы программного кода. Дополнительные ограничения такого подхода определяются ограничениями программ-генераторов – описанное средство создает код только для одного ORM-фреймворка. 

Создать работающую систему с помощью таких инструментов невозможно.

### Конструкторы приложений
Непосредственно для создания учётных систем могут использоваться конструкторы приложений; один из примеров – Zoho Creator [2]. Этот инструмент представляет собой сервис для автоматизации потоков данных. Приложения создаются с помощью WYSIWIG-конструктора и средств визуального моделирования.

Сервис рассчитан на пользователей, не знакомых с программированием. Предусмотрены возможности для расширения с помощью скриптов на собственном языке, но выполнить произвольный код в приложении невозможно. Кроме того, созданное приложение размещается только на серверах компании Zoho на коммерческих условиях [8].

### Критерии сравнения аналогов
В качестве критериев сравнения выбраны:

* **Работа с формальными моделями** - возможность работы с формальными моделями предметной области  
    Формальные модели представляют описание предметной области в терминах этой области, что облегчает разработку.  
    Кроме того, в рамках рассматриваемой задачи многие части системы (например, структура БД, формы) однозначно зависят от модели предметной области. Имеется явная возможность для автоматизации.
* **Создание интерфейса пользователя** - предоставление интерфейса пользователя для взаимодействия с созданной системой.  
    Интерфейс пользователя - существенная часть системы; автоматизация создания интерфейса (или предоставление готового) уменьшит работу по настройке системы.
* **Отсутствие привязки к серверу** - возможность развёртывания итоговой системы на собственном сервере.  
    Альтернатива - развертывание на сервере компании-производителя. Во-первых, это означает тарификацию по планам этой компании, во-вторых - неприемлемо для конфиденциальных данных.

### Таблица сравнения
Результаты сравнения представлены на~\ref{table:comparison}

Таблица сравнения:[//]: # (\label{table:comparison})
|                                  | ERDPlus | SQLDBm | MySQL WB | VP | ZoHo |
|----------------------------------|---------|--------|----------|----|------|
| Работа с формальными моделями    | +       | +      | +        | +  | -    |
| Создание интерфейса пользователя | -       | -      | -        | -  | +    |
| Отсутствие привязки к серверу    | +       | +      | +/-      | +  | -    |

### Выводы по итогам сравнения
Среди рассмотренных аналогов, конструкторы приложений лучше всего подходят для решения задачи. Однако, те не предоставляют достаточного уровня расширяемости (возможности исполнять произольный программный код) и привязаны к серверам производителя [2].

Другие рассмотренные подходы решают только часть задачи, и программисту остается значительная часть работы - создание интерфейса пользователя.

## Описание архитектуры решения

![Архитектура системы\label{img:arch_comp}](img/arch_comp.png)

На рис.~\ref{img:arch_comp} приведена архитектура разрабатываемой системы.  В ней в качестве базы данных используется PostgreSQL. По производительности RDBMS несильно уступает NoSQL-решениям, на небольших наборах данных разница незаметна [9]. Система разделена на две части: создаваемый макет и создающая программа («генератор»). В качестве языка программирования серверной части выбран Python 3 по причине простоты и компактности [10], а также возможности динамического подключения модулей.

На стороне сервера макета используется веб-фреймворк Flask, обеспечивающий доступ к системе через REST API. Для компенсации Global Interpreter Lock система будет запускаться на сервере веб-приложений Gunicorn [11].

На стороне сервера используется ORM – для предоставления гибкого API для скриптов бизнес-логики и общего упрощения разработки [12]. Предусмотрена возможность встраивать скрипты бизнес-логики. Скриптам дан доступ к API системы, в частности – доступ к данным таблиц (моделям ORM), возможность прерывать действия пользователя, запрашивать у него данные через экранные формы.

На уровне представления использован фреймворк Vue.js [13]. Предусмотрены компоненты для отображения таблиц, представлений, форм; в интерфейс пользователя можно встраивать произвольные страницы и кнопки, запускающие скрипты бизнес-логики [14].

Присутствует система контроля полномочий и разделение пользователей по ролям. Каждый пользователь имеет одну или несколько полей, каждая роль имеет свой набор прав доступа к таблицам и компонентам системы.

Программа-генератор представляет собой GUI-приложение. Он выполняет настройку системы – редактирование и подключение ER-моделей, управление контролем доступа, настройка интерфейса представления, подключение скриптов бизнес-логики.

В случае, если возможностей программы-генератора недостаточно, пользователю предоставляется возможность редактировать исходный код создаваемой системы.

### Хранение данных
Сгенерированные на основе ERD таблицы хранятся в соответствующих схемах (schema); таблицы с системной информацией – в схемах System и Generator.

Роль пользователя может быть поставлена в соответствие какой-либо сущности ER-модели. В таком случае в базе будет образована необходимая связь, а в профиле пользователя появятся соответствующие поля.

Часть системной информации хранится в базе данных. ER-модели, настройки интерфейса системы и контроля доступа в формате XML.

## Основные алгоритмы и структуры
### ER-метод моделирования структуры
Рассмотрим создание программы-менеджера задач. Задачи группируются по спискам; каждая имеет название, дату, описание и может включать в себя несколько подзадач; подзадачи состоят из нескольких пунктов. Каждый пункт имеет статус – завершен или не завершен. К задаче могут присоединяться вложения, добавляться комментарии и назначаться участники. Соответствующая ER-модель в нотации Мартина [15] преставлена на рис.~\ref{img:er}

![ER-модель для примера\label{img:er}](img/model.png)

В системе ER-модель хранится в формате XML. В неё добавлена дополнительная информация: тип атрибута, является ли атрибут ключевым, является ли отношение частью ключа. 

С учётом этого, описание сущности “Задача” в XML:

```
<entity id="1">
    <name>Задача</name>
    <attribute>
        <name>Название</name>
        <isPk>true</isPk>
        <type>varchar[200]</type>
    </attribute>
    <attribute>
        <name>Дата окончания</name>
        <type>date</type>
    </attribute>
    <attribute>
        <name>Описание</name>
        <type>text</type>
    </attribute>
</entity>
```

Описание связи “Принадлежит” между сущностями “Задача” и “Список”:
```
<relation>
    <name>Принадлежит</name>
    <side>
        <idRef>1</idRef>
        <isMandatary>false</isMandatary>
        <isMultiple>true</isMultiple>
    </side>
    <side>
        <idRef>2</idRef>
        <isMandatary>true</isMandatary>
        <isMultiple>false</isMultiple>
    </side>
</relation>
```
Программа генерирует соответствующую реляционную модель с помощью алгоритма, описанного в [5].

### Генерация кода
На основании реляционной модели, полученной на предыдущем этапе, создаются классы (модели) SQLAlchemy.
На каждое отношение генерируется одна таблица c соответствующими атрибутами и отношениями. ORM SQLAlchemy позволяет получить доступ к связанным таблицам как к атрибутам модели, что облегчает написание скриптов бизнес-логики [16]

Пример моделей, сгенерированных по отношениям «Задача» и «Список»:
```
class Task(Base):
  __tablename__ = 'task'
  __table_args__ = {"schema": "ER1"}
    
  name = Column(String, primary_key=True)
  finish_date = Column(DateTime)
  description = Column(Text)
  list_name = Column(String(256), ForeignKey('ER1.list.name', onupdate='cascade', ondelete='cascade'))
  
  list_on = relationship('List', backref='tasks')
  

class List(Base):
  __tablename__ = 'list'
  __table_args__ = {"schema": "ER1"}

  name = Column(String(256), primary_key=True)

```

## Описание эксперимента
В результате генерируется web-приложение, в котором для развертывания использован nginx [17] и Gunicorn. Для компенсации Global Interpreter Lock на стороне Gunicorn используется 9 процессов (workers) [11]

Измеряется зависимость времени выполнения запросов от наполнения БД. Важно, что при написании скриптов бизнес-логики имеет значение время выполнения запроса через программный код, при настройке клиента – через REST API.

![Накладные расходы REST API\label{img:rest}](img/chart_1.PNG)

Запросы к одной таблице (в обоих случаях) выполняются за приемлемое время; для 100 000 записей запрос к 1-й странице занимает в среднем (n=5) 14 мс, к 10000-й – 69 мс, причем фильтрация и сортировка по индексированным полям время не ухудшают.

При больших объемах возвращаемых данных время выполнения запроса возрастает (рис.~\ref{img:rest}).

Наиболее серьезное снижение производительности наблюдается при запросе на получение одной записи с данными из всех связанных таблиц (рис.~\ref{img:rest_linked}). Решить данную проблему можно, например, установкой ленивой инициализации для нужных случаев на стороне клиента

![Запрос к REST API на получение одной записи с данными из связанных таблиц\label{img:rest_linked}](img/chart_2.PNG)

Следует отметить, что в реальном использовании накладные расходы на латентность сети и скорость соединения чаще всего многократно превысят рассмотренные издержки. 

С помощью фреймворка нагрузочного тестирования веб-приложений Locust [18] проведено измерение максимального числа одновременных запросов к REST API. Сгенерированное web-приложение успешно справилось с одновременной обработкой запросов от 1024 виртуальных пользователей.

## Заключение
Возможности применения существующих решений для решения поставленной задачи ограничены; рассмотренные решения либо не предоставляют достаточной расширяемости, либо не решают задачу полностью.

Для создания структуры БД выбран алгоритм [5]. На основе этого алгоритма произведено создание приложения для простой предметной области.

Сгенерированное web-приложение показывает хорошую (время отклика менее 1 сек) производительность при заполнении большим (более 50 000 записей) количеством данных, а используемый стек технологий дает возможность одновременной работы с системой как минимум 1000 пользователям.

Определённые структуры данных (более 10 000 связанных записей на одну) могут обрабатываться системой неэффективно. В этом случае необходимо вмешательство со стороны программиста.

В отличие от рассмотренных аналогов, данная система может быть развернута на собственном сервере; расширяемость обеспечивается возможностью выполнения на стороне сервера произвольного кода скриптов бизнес-логики.

В дальнейшей работе, может быть полезно ввести дополнительные шаги в проектирование структуры БД, таких как установка индексов и ограничений. Отдельного рассмотрения заслуживают вопросы настройки уровня отображения (клиента). В совокупности эти пункты позволят сократить объем вмешательства в исходный код созданной системы.